---
title: Dynamics IDs
---

In order to improve compatibility between mods and make the integration with
the game as unintrusive as possible, kzModUtils uses a strategy to dynamically
create new IDs for game elements, such as items, events, etc.

Since the game engine uses numerical IDs, having each mod author pick an ID
that won't overlap with another mod, or even with game updates (if there is ever one)
is quite challenging. Given that, using dynamic IDs solve this issue, since
each game save may track its own set of custom IDs with a key that mod authors
can easily make it unique.

The used approach is to use textual identifiers for those objects, and leave
to kzModUtils the job of converting it to numerical IDs that doesn't overlaps
with the game one. And to also take care of remapping between game saves,
even if mods were installed in different orders or are now missing.

To acomplish that, kzModUtils have in its code the safe ranges where it may
create new IDs, and along with that, it stores for each game save a map
between the modder-defined identifier (text) to which numerical ID it represents
in this game save.

For example, I may have 2 mods in my game:

- The first one adds an item identified by `myCoolMod.item1`
- The second one adds another item identified by `dogFoods.simpleFood`

When the game save is being loaded, kzModUtils will check `SaveData*_kzModUtils.dat`
file for a mapping that will have something like:

| Identifier Text       | ID     |
| --------------------- | ------ |
| `myCoolMod.item1`     | 100001 |
| `dogFoods.simpleFood` | 100002 |

and with that information, it will finish loading the game save associating
those IDs to the actual item.

In case the ID is not yet mapped, kzModUtils will take the next free ID and
create a new map entry for it.

If a mod gets removed, the loading process may also identify that and perform
proper clean up, like getting rid of this ID and removing the item from player
data. This way, when the game gets saved again, the mod gets completely removed.


## Config Classes
Now that you understand the general idea of the dynamic IDs, let's talk
about how this affects you, the modder using kzModUtils.

kzModUtils uses "Config Classes" to interface with mods. Everything that
needs to be registered in kzModUtils will require you to create a Config
Class for that element. For example, a new item requires a `CustomItemConfig`,
a new event will require a `EventConfig` and so on.

All those classes will require a text ID as one of its parameters in their
constructor. And it will use this text ID for internal reference as explained
above.

After registration and a game save being loaded, kzModUtils will then fill
a property called `Id` in this config. This property may change at any time
as user saves and load game files, so **NEVER** store this value somewhere else.

!!! caution
	**NEVER** store the read-only IDs generated by config classes, you should
	always refer to those IDs using the instance of the class so you get the
	new value whenever they change.

By leveraging the classes as a container for those IDs, we are able to keep
both kzModUtils and the consuming mod in sync.


## The `IdHolder` class
Config classes works really well for custom entries, but sometimes we want
to mix custom stuff with the original ones. And here comes an issue:

- Original items, events, etc uses a numerical (`int`) ID
- Custom items, events, etc **MUST** use their Config classes

The solution for that is the `IdHolder` class. `IdHolder` is able to work
with both Config Classes (which implements `IIdentifiableConfig`) and `int`
values.

By using it, references to both will work seamlessly. So whenever you have
to reference something in kzModUtils, it is likely that you will need an
`IdHolder`. Don't fret, you just have to instantiate one:

```C#
var myCustomItemHolder = new IdHolder<CustomItemConfig>(customItem);
// or
var myOriginalItemHolder = new IdHolder<int>(10000);
```

